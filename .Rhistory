colnames(RasterList) <- c("sp", 'RasterList')
}
# Vector with species names, and proving if records and raster layer
# have the same specie names
SpNames <- as.character(unique(records[, sp]))
SpNamesR <- RasterList[, "sp"]
if (any(!SpNames %in% SpNamesR)) {
message(sum(!SpNames %in% SpNamesR),
' species names differ between records and raster files')
message("Next names were not found in records database: ",
paste0(SpNamesR[!SpNames %in% SpNamesR], " "))
message("Next names were not found in raster layers: ",
paste0(SpNames[!SpNames %in% SpNamesR], " "))
stop("species names must be the same in records, absences and raster layers")
}
#### threshold for MCPB method
if (method == "MCPB") {
cat("Select buffer distance (km):")
CUT_Buf <- (as.numeric(readLines(n = 1))) * 1000
}
# loop to process each species
for (s in 1:length(SpNames)) {
print(paste(s, "from", length(SpNames), ":", SpNames[s]))
# Read the raster of the species
Adeq <-
raster(RasterList[RasterList[, "sp"] == SpNames[s], 'RasterList'])
# if (is.na(crs(Adeq))) {
#   crs(Adeq) <-
#     "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
# }
# Extract values for one species and calculate the threshold
singleSpData <- SpData[SpData$sp == SpNames[s], ]
PredPoint <- extract(Adeq, singleSpData[, c(x, y)])
PredPoint <-
data.frame(pres_abse = singleSpData[, 'pres_abse'], PredPoint)
Eval <- evaluate(PredPoint[PredPoint$pres_abse == 1, 2],
PredPoint[PredPoint$pres_abse == 0, 2])
Thr <- unlist(c(threshold(Eval))[threshold])
#### MCP method----
if (method == "MCP") {
hull <-
convHull(singleSpData[singleSpData[, "pres_abse"] == 1, c("x", "y")], lonlat = TRUE)
hull <- predict(Adeq, hull, mask = TRUE)
Adeq[(hull[] == 0)] <- 0
writeRaster(
Adeq,
paste(foldCon, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
Mask <- Adeq > Thr
writeRaster(
Mask,
paste(foldCat, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
}
# MCPB mthods-----
if (method == "MCPB") {
hull <-
convHull(singleSpData[singleSpData[, "pres_abse"] == 1, c("x", "y")], lonlat = TRUE)
hull <- predict(Adeq, hull, mask = TRUE)
pts1 <-
singleSpData[singleSpData[, "pres_abse"] == 1, c("x", "y")]
spraster <- rasterize(pts1, Adeq, field = 1)
sps <- as(spraster, 'SpatialPixels')@coords
dist <- dist2(sps, sps, method = 'euclidean', p = 2)
dist[dist == 0] <- NA
distmin <- apply(dist, 1, function(x)
min(x, na.rm = T))
hull2 <- hull
hull2[hull2[] == 0] <- NA
hull2 <- boundaries(hull2)
hull2[hull2[] == 0] <- NA
df <- rasterToPoints(hull2)
df <- df[df[, 3] == 1,-3]
buf <- circles(df, lonlat = T, d = CUT_Buf)
buf <- predict(Adeq, buf,  mask = TRUE)
buf[(hull[] == 1)] <- 1
buf[(!is.na(Adeq[]) & is.na(buf[]))] <- 0
Adeq[which(buf[] != 1)] <- 0
writeRaster(
Adeq,
paste(foldCon, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
Mask <- (Adeq > Thr)
writeRaster(
Mask,
paste(foldCat, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
}
if (method %in% c("OBR", "LQ", "PRES")) {
# Transform coordinate in a SpatialPoints object
pts1 <-
singleSpData[singleSpData[, "pres_abse"] == 1, c("x", "y")]
coordinates(pts1) <- ~ x + y
crs(pts1) <- crs(Adeq)
# Raster with areas equal or grater than the threshold
AdeqBin <- Adeq >= as.numeric(Thr)
AdeqBin[AdeqBin[] == 0] <- NA
# A "SpatialPolygonsDataFrame" which each adequability patch is a feature
AdeqBin2 <-
rasterToPolygons(
AdeqBin,
fun = NULL,
n = 8,
na.rm = TRUE,
digits = 12,
dissolve = TRUE
)
AdeqBin2 <- disaggregate(AdeqBin2)
AdeqBin2$layer <- NULL
# Individualize each patch with a number
AdeqBin2$ID <- 1:length(AdeqBin2)
# create a data.frame wiht coordinate and patch number
AdeqPoints <- rasterToPoints(AdeqBin)[, 1:2]
AdeqPoints <-
cbind(AdeqPoints, ID = extract(AdeqBin2, AdeqPoints)[, 'ID'])
# Find the patches that contain presences records
polypoint <- intersect(AdeqBin2, pts1)
# PRES methods------
if (method == "PRES") {
Adeq2 <- Adeq
Msk <- rasterize(polypoint, Adeq, background = 0)
Msk[is.na(Adeq[])] <- NA
Adeq2[Msk != 1] <- 0
writeRaster(
Adeq2,
paste(foldCon, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
Mask <- Adeq2 >= Thr
writeRaster(
Mask,
paste(foldCat, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
} else{
# Create a vector wich contain the number (e.i. ID) of the patches
# with presences
filter1 <- unique(polypoint$ID)
# In this step are created two data.frame one with the patches coordinates
# that contain presences and another with patches coordinates without presences
CoordPathP <-
as.data.frame(AdeqPoints[AdeqPoints[, 3] %in% filter1,])
CoordPathNP <-
as.data.frame(AdeqPoints[!AdeqPoints[, 3] %in% filter1,])
# Here is created a matrix wiht all combination between ID of patches
# with and without presences
if (ncol(CoordPathP) == 1) {
CoordPathP <- data.frame(t(CoordPathNP))
rownames(CoordPathP) <- NULL
}
if (ncol(CoordPathNP) == 1) {
CoordPathNP <- data.frame(t(CoordPathNP))
rownames(CoordPathNP) <- NULL
}
npatch1 <- unique(CoordPathP[, 3])
npatch2 <- unique(CoordPathNP[, 3])
DistBetweenPoly0 <- expand.grid(npatch1, npatch2)
DistBetweenPoly0$Distance <- NA
DistBetweenPoly0 <- as.matrix(DistBetweenPoly0)
# Euclidean Distance between patches wiht and without presences
for (i in 1:nrow(DistBetweenPoly0)) {
comb <- (DistBetweenPoly0[i, 1:2])
A <- CoordPathP[CoordPathP[, 3] == comb[1], 1:2]
B <- CoordPathNP[CoordPathNP[, 3] == comb[2], 1:2]
if (nrow(A) >= 40) {
SEQ <- round(seq(0, nrow(A), by = (nrow(A)) / 20))
dist <- rep(NA, length(SEQ))
for (j in 2:length(SEQ)) {
SEQ2 <- (SEQ[(j - 1)] + 1):SEQ[j]
dist[j] <-
min(dist2(A[SEQ2, ], B, method = 'euclidean', p = 2), na.rm = T)
}
eucdist <- min(dist[2:length(SEQ)], na.rm = T)
} else{
eucdist <- min(dist2(A, B, method = 'euclidean', p = 2))
}
DistBetweenPoly0[i, 3] <- eucdist
}
DistBetweenPoly0 <-
DistBetweenPoly0[order(DistBetweenPoly0[, 2]),]
# Minimum Euclidean Distance between patches wiht and without presences
DistBetweenPoly <-
tapply(X = DistBetweenPoly0[, 3], DistBetweenPoly0[, 2], min)
# Adding value of distance patches to cells
AdeqBin2$Eucldist <- 0
AdeqBin2$Eucldist[!AdeqBin2$ID %in% filter1] <-
round(DistBetweenPoly, 4)
# OBR method------
if (method == 'OBR') {
# method based on the maximum value of the minimum distance
spraster <- rasterize(pts1, Adeq, field = 1)
sps <- as(spraster, 'SpatialPixels')@coords
dist <- dist2(sps, sps, method = 'euclidean', p = 2)
dist[dist == 0] <- NA
distmin <- apply(dist, 1, function(x)
min(x, na.rm = T))#
CUT <- max(distmin)
}
if (method == "LQ") {
# method based the lower quartile distance
CUT <- c(summary(DistBetweenPoly0[, 3]))[2]
}
AdeqPoints <- rasterToPoints(AdeqBin)[, 1:2]
AdeqPoints <- extract(AdeqBin2, AdeqPoints)[, 'Eucldist']
fist <- AdeqBin
fist[fist[] == 1] <- AdeqPoints
# Threshold based on Maximum value of minimum ditance between ocurrences
final <- fist <= CUT
final[final == 0] <- NA
Adeq2 <- Adeq
Mask <- Adeq >= as.numeric(Thr)
Mask[Mask == 1] <- 0
Mask[!is.na(final[])] <- 1
Adeq2[Mask != 1] <- 0
# Save results as raster object
writeRaster(
Adeq2,
paste(foldCon, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
writeRaster(
Mask,
paste(foldCat, paste(SpNames[s], '.tif', sep = ""), sep = "/"),
format = "GTiff",
overwrite = TRUE
)
}
# MCPB mthods----
MSDM_Posteriori(records=occurrences, absences=absences,
x="x", y="y", sp="sp", method="MCPB",
dirraster = dir_raster, threshold = "spec_sens",
dirsave = tmdir)
library(MSDM)
# MCPB mthods----
MSDM_Posteriori(records=occurrences, absences=absences,
x="x", y="y", sp="sp", method="MCPB",
dirraster = dir_raster, threshold = "spec_sens",
dirsave = tmdir)
# LQ mthods----
MSDM_Posteriori(records=occurrences, absences=absences,
x="x", y="y", sp="sp", method="LQ",
dirraster = dir_raster, threshold = "spec_sens",
dirsave = tmdir)
tmdir
tmdir <- tempdir()
tmdir
dir.create(file.path(tmdir,"MSDM"))
tmdir <- file.path( tmdir,"MSDM")
tmdir
library(MSDM)
require(MSDM)
require(raster)
?MSDM_Priori()
?MSDM_Posteriori()
library(MSDM)
MSDM_Priori()
MSDM_Priori
library(MSDM)
dismo::threshold()
?dismo::threshold()
library(MSDM)
getRversion()
if(getRversion() >= "2.15.1")  utils::globalVariables(c("."))
# EXEMPLO COM OS METODOS A PRIORI-------------
library(MSDM)
library(raster)
data("rlayer")
data("occurrences")
rlayer
occurrences
tmdir <- tempdir()
tmdir # temporal directory where will be saves raster layers
records = occurrences
y = "y"
x = "x"
sp = "sp"
method = "XY"
dirsave = tmdir
rasterlayer = rlayer
Species <- split(records[, c(x, y)], records[, sp])
method
DirPRI <- "MSDM_MIN"
dir.create(file.path(dirsave, DirPRI))
DirPRI <- file.path(dirsave, DirPRI)
spi <- as(rasterlayer, 'SpatialPixels')@coords
spi
dim(spi)
coordinates(rasterlayer)
head(coordinates(rasterlayer))
head(spi)
dim(spi)
dim(coordinates(rasterlayer))
values(rasterlayer)
globalVariables(".")
globalVariables("as")
globalVariables()
globalVariables(as)
as(spraster, 'SpatialPixels')@coords
as(rasterlayer, 'SpatialPixels')@coords
canCoerce(rasterlayer, 'SpatialPixels')@coords
canCoerce(rasterlayer, 'SpatialPixels')
as(rasterlayer, 'SpatialPixels')
coordinates(as(rasterlayer, 'SpatialPixels'))
dim(coordinates(as(rasterlayer, 'SpatialPixels')))
data(occurrences)
str(occurrences)
unique(occurrences$sp)
occurrences
library(MSDM)
data("absences")
absences
str(absences)
str(occurrences)
library(MSDM)
require(MSDM)
require(raster)
data("occurrences")
data("absences")
dir_raster <- system.file("extdata", package="MSDM")
# List of raster layer with species suitability
list.files(dir_raster, full.names = TRUE)
# Create a temporary MSDM folder
tmdir <- tempdir()
tmdir
dir.create(file.path(tmdir,"MSDM"))
tmdir <- file.path( tmdir,"MSDM")
tmdir
list.files(tmdir)
list.files(dir_raster, full.names = TRUE)
raster(list.files(dir_raster, full.names = TRUE)[1]
)
raster(list.files(dir_raster, full.names = TRUE)[1]
plot()))
plot(raster(list.files(dir_raster, full.names = TRUE)[1]
)))
plot(raster(list.files(dir_raster, full.names = TRUE)[1]
))
str(rlayer)
library(MSDM)
require(raster)
data("rlayer")
plot(rlayer)
library(MSDM)
version(rgdal)
package_version(rgdal)
package_version('rgdal')
require(rdal)
require(rgdal)
library(MSDM)
occurrences <- "C:/Users/Santiago/OneDrive/Documentos/FORESTAL/1-Trabajos/43-MSDM/models/virtua_amostra.txt"
occurrences <- read.table(occurrences, header = T, sep = '\t', stringsAsFactors = F)
head(occurrences)
occurrences <- occurrences[occurrences$sp%in%c("SP01", "SP02", "SP03", "SP04", "SP05"),]
occurrences
absences <- "C:/Users/Santiago/OneDrive/Documentos/FORESTAL/1-Trabajos/43-MSDM/models/PseudoAusencias.txt"
absences <- read.table(absences, header = T, sep = '\t', stringsAsFactors = F)
colnames(absences)[1] <- 'sp'
head(absences)
absences$sp <- as.character(absences$sp)
absences$sp[absences$sp%in%1:9] <- paste0('0',absences$sp[absences$sp%in%1:9])
head(absences)
absences$sp <- paste0('SP', absences$sp)
absences <- absences[absences$sp%in%c("SP01", "SP02", "SP03", "SP04", "SP05"),]
dim(absences)
absences <- "C:/Users/Santiago/OneDrive/Documentos/FORESTAL/1-Trabajos/43-MSDM/models/PseudoAusencias.txt"
absences <- read.table(absences, header = T, sep = '\t', stringsAsFactors = F)
colnames(absences)[1] <- 'sp'
head(absences)
absences$sp <- as.character(absences$sp)
absences$sp[absences$sp%in%1:9] <- paste0('0',absences$sp[absences$sp%in%1:9])
head(absences)
absences$sp <- paste0('SP', absences$sp)
absences$sp
absences <- "C:/Users/Santiago/OneDrive/Documentos/FORESTAL/1-Trabajos/43-MSDM/models/PseudoAusencias.txt"
absences <- read.table(absences, header = T, sep = '\t', stringsAsFactors = F)
colnames(absences)[1] <- 'sp'
head(absences)
absences$sp
absences$sp[absences$sp%in%1:9] <- paste0('0',absences$sp[absences$sp%in%1:9])
absences$sp
absences <- absences[absences$sp%in%c("SP01", "SP02", "SP03", "SP04", "SP05"),]
absences$sp
absences <- "C:/Users/Santiago/OneDrive/Documentos/FORESTAL/1-Trabajos/43-MSDM/models/PseudoAusencias.txt"
absences <- read.table(absences, header = T, sep = '\t', stringsAsFactors = F)
head(absences)
absences <- "C:/Users/Santiago/OneDrive/Documentos/FORESTAL/1-Trabajos/43-MSDM/models/PseudoAusencias.txt"
absences <- read.table(absences, header = T, sep = '\t', stringsAsFactors = F)
absences <- absences[absences$sp%in%c("SP01", "SP02", "SP03", "SP04", "SP05"),]
head(absences)
dim(absences)
getwd()
save(occurrences, file="data/occurrences.RData")
save(absences, file="data/absences.RData")
library(MSDM)
data(absences)
unique(absences$sp)
require(devtools)
is.null(buffer)
buffer=NULL
is.null(buffer)
method =
"BMCP"
method == "BMCP" & is.null(buffer)
buffer <- 50
is.numeric(buffer)
buffer <- 50.5
is.numeric(buffer)
library(MSDM)
require(roxygen2)
library(MSDM)
packageDescription('geosphere')
library(MSDM)
MSDM_Posteriori()
MSDM_Posteriori
packageDescription('MSDM')
library(MSDM)
MSDM_Posteriori
library(MSDM)
MSDM_Posteriori
library(MSDM)
require(devtools)
library(MSDM)
MSDM_Posteriori()
MSDM_Posteriori
buffer='single'
method =
"BMCP"
(method == "BMCP" & length(buffer)>1)
(method == "BMCP" & buffer=="sigle")
(method == "BMCP" & buffer=="single")
library(MSDM)
raster::gridded
documents()
devtools::document()
methods::as
require(MSDM)
data("rlayer")
rlayer
plot(rlayer)
rlayer
require(MSDM)
require(raster)
require(roxygen2)
require(devtools)
w(rlayer)
?(rlayer)
?rlayer
rlayer
package.skeleton
package.skeleton()
# create dataset for this package
list.files('./layers')
# create dataset for this package
list.files('./layers', full.names = T)
# create dataset for this package
list.files('C:/Users/santi/Documents/GitHub/MSDM_data/layers', full.names = T)
require(dplyr)
# create dataset for this package
'C:/Users/santi/Documents/GitHub/MSDM_data/layers' %>% list.files(., full.names = T) %>% stack() %>% brick()
# create dataset for this package
sp_model <- 'C:/Users/santi/Documents/GitHub/MSDM_data/layers' %>% list.files(., full.names = T) %>% stack() %>% brick()
plot(sp_model)
sp_model
X11()
plot(sp_model)
names(sp_model)
crs(sp_model)
# raster::crs(sp_model) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84"
getwd()
# Will be expored this data as *.Rdata but compressing them bzip2
sdms <- 'C:/Users/santi/Documents/GitHub/MSDM_data/layers' %>% list.files(., full.names = T) %>% stack() %>% brick()
# Will be expored this data as *.Rdata but compressing them bzip2
sp_sdm <- 'C:/Users/santi/Documents/GitHub/MSDM_data/layers' %>% list.files(., full.names = T) %>% stack() %>% brick()
save(sp_sdm, file="C:/Users/santi/Documents/GitHub/MSDM/data/sp_sdm.RData", compress = 'bzip2')
data("occurrences")
occurrences
##%######################################################%##
#                                                          #
####                  create documents                  ####
#                                                          #
##%######################################################%##
devtools::document()
getwd()
##%######################################################%##
#                                                          #
####                  create documents                  ####
#                                                          #
##%######################################################%##
devtools::document()
##%######################################################%##
#                                                          #
####                  create documents                  ####
#                                                          #
##%######################################################%##
devtools::document()
##%######################################################%##
#                                                          #
####                  create documents                  ####
#                                                          #
##%######################################################%##
devtools::document()
